---
layout: post
title:  "Assembly: the start of many failures"
date:   2021-11-17 20:17:21 +0330
categories: jekyll update
tags: 
   -reversing
---
Hello! This is the start of my reverse engineering journey. I'm starting from knowing almost nothing and hopefully will learn a lot along the way. Maybe this journey will help people learn things following my steps. I will try to write everything here. All of my dumb failures and epic wins. So here we go!

## Helloworld Assembly!
First things first I must say I have bare minimum understanding of assembly and it's heavily needed in reverse engineering. So for my first step im going to copy paste a hello world code and rewrite it and try to learn everything on it. But before that we need to install 'nasm'. nasm seems to be the compiler for assembly for lack of better word. I might be wrong but that's the whole point of this log, to be wrong and learn from it. 
I'm using arch linux so : `yay -S nasm`
Now to copy paste the code in HelloWorld.asm:
{% highlight assembly %}{% raw %}
section	.text
   global_start   ;must be declared for linker (ld)
	
_start:	          ;tells linker entry point
   mov	edx,len   ;message length
   mov	ecx,msg   ;message to write
   mov	ebx,1     ;file descriptor (stdout)
   mov	eax,4     ;system call number (sys_write)
   int	0x80      ;call kernel
	
   mov	eax,1     ;system call number (sys_exit)
   int	0x80      ;call kernel

section	.data
msg db 'Hello, world!', 0xa  ;string to be printed
len equ $ - msg     ;length of the string
{% endraw %} {% endhighlight %}

I can already understand a few things from the comments but it's not nearly enough for me. If this is the basic assembly I'm going to do my research about every single command there. but let's not worry about that now and just compile this piece of code.

## Compiling
To start compiling we have to start with:
`nasm -f elf HelloWorld.asm`
>`-f` specifies format
>`elf` is a file format

The command made another file called `Helloworld.o`. 'o' extension means object file and we still dont have an executable. We have simply "assembled" our source file.
Now i tried this command to make my .o file an executable:
`ld -o HelloWorld Helloworld.o`
It returned an error: 

{% highlight assembly %}{% raw %}
>ld: i386 architecture of input file `Helloworld.o' is incompatible with i386:x86-64 output
>ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000"
{% endraw %} {% endhighlight %}

So we have an error on our hand and a warning. error is saying we are inputing i386 architecture but output is i386:x96-64. 
I looked it up and realized what's the problem for our first error. Apparently when we ran the command `nasm -f elf Helloworld.asm` we made a 32 bit object file and if we wanted to make 64bit we should have entered `nasm -f elf64 Helloworld.asm`. This is a problem because apparently by default our ld command wants to make 64bit executable but we gave it 32 bit. so let's rm our object file and try again with 64bit shall we. 

>`nasm -f elf64 Helloworld.asm`

and now:
>`ld -o HelloWorld Helloworld.o`

and voila we were correct error is gone! I'm going to ignore the warning for now because it seems to correct itself. Bad practice yes but im already tired from debugging. XD

btw ld is the linker. linker I assume needs to link different parts of our code. so it needs to find entry point and needs to link other files and functions to it.

Now lets keep going. if `HelloWorld` is an executable we should be able to run it. 
`./HelloWorld`

> "Hello, World!"
Finally. 

## Learning what our assembly program does and rewriting it

>section .text:

Let's divide it into two parts: section and text.
"A section is the smallest unit of an object file that can be relocated. "

Object file seems to repeat itself a lot. I assume it's something important. Object file means:
"An object file contains the same instructions in machine-readable, binary form"

Great so now that is out of the way. there seems to be many type of sections:
>Sections containing the following material usually appear in relocatable ELF files:
>The data section,

>The bss section, and

>The text section.

>The text section is used for keeping the actual code. This section must begin with the declaration global _start, which tells the kernel where the program execution begins.

Ok, now we know what `section .text` is, what does global start do. we have another start in the code. So what is their difference? 
"

